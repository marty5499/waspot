<!DOCTYPE html>
<html>

<head>
    <script src="../js/oo/camera.js"></script>
    <script src="../js/opencv.js"></script>
    <script src="../js/oo/imageFilter.js"></script>
</head>

<body>
    <canvas id='c1' width=320 height=240></canvas>
    <canvas id='c2' width=320 height=240></canvas>
    <canvas id='c3' width=320 height=240></canvas>
    <br><a href="index.html">回首頁</a>
    <script>
        var cam = new Camera('roadLane2.mp4');
        var minX = 0, maxX = 0;
        var minY = 0, maxY = 0;
        var vColor = { "low": [53, 1, 135, 0], "high": [131, 18, 255, 255], "erosion": 0, "dilation": 0 };
        //vColor = { "low": [77, 1, 131, 0], "high": [146, 56, 255, 255], "erosion": 1, "dilation": 1 };
        vColor = { "low": [138, 36, 187, 0], "high": [180, 255, 255, 255], "erosion": 0, "dilation": 5 };
        //cam.setRotate(90);
        var roiWidth = 320, roiHeight = 240;
        var roi = [0, 0, roiWidth, roiHeight];
        var lastLeftLane = {}, lastRightLane = {};

        cam.onCanvas('c1', function (canvas) {
            let ctx = canvas.getContext('2d');
            let ctx2 = c2.getContext('2d');
            let ctx3 = c3.getContext('2d');
            let src = cv.imread(canvas);
            let dst = new cv.Mat();
            let dst2 = new cv.Mat();

            // ROI
            let rect = new cv.Rect(roi[0], roi[1], roi[2], roi[3]);
            dst = src.roi(rect);

            // Color Filter
            cv.cvtColor(dst, dst, cv.COLOR_RGB2HSV, 0);
            cv.imshow('c2', dst);
            let low = new cv.Mat(dst.rows, dst.cols, dst.type(), vColor.low);
            let high = new cv.Mat(dst.rows, dst.cols, dst.type(), vColor.high);
            cv.inRange(dst, low, high, dst);
            // Canny
            cv.Canny(dst, dst, 250, 250, 5, false);
            //HoughLines
            let lines = new cv.Mat();
            let drawLines = [];
            cv.HoughLines(dst, lines, 1, Math.PI / 180, 35, 0, 0, 0, Math.PI);
            cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGB, 0);
            // draw lines
            for (let i = 0; i < lines.rows; ++i) {
                let rho = lines.data32F[i * 2];
                let theta = lines.data32F[i * 2 + 1];
                let a = Math.cos(theta);
                let b = Math.sin(theta);
                let x0 = a * rho;
                let y0 = b * rho;
                vvv = 1000;
                let startPoint = { x: x0 - vvv * b, y: y0 + vvv * a };
                let endPoint = { x: x0 + vvv * b, y: y0 - vvv * a };
                var degree = 180 - theta * 180 / Math.PI;
                //if ((degree > 120 && degree < 145) || (degree > 30 && degree < 60)) {
                cv.line(dst, startPoint, endPoint, [255, 0, 0, 255]);
                drawLines.push([rho, theta]);
                //}
            }
            cv.imshow('c2', dst);
            lines.delete();

            //*/ output Canvas #3
            ctx3.fillStyle = "#000000";
            ctx3.fillRect(0, 0, c3.width, c3.height);
            //var imgData = ctx2.getImageData(0, 0, c2.width, c2.height);
            //ctx3.putImageData(imgData, roi[0], roi[1]);
            //[60, 170, 180, 65];
            drawLineArray(drawLines, roi[0], roi[1], roi[2], roi[3], ctx3);
            drawCircle(ctx, lastLeftLane.x, lastLeftLane.y + 50, 10, '#ffff00');
            drawCircle(ctx, lastRightLane.x, lastRightLane.y + 50, 10, '#ff00ff');
            if (window.qq == 1) {
                console.log(ff);
            }
            low.delete();
            high.delete();
            src.delete();
            dst.delete();
            dst2.delete();
        });


        function drawLineArray(drawLines, startX, startY, width, height, ctx) {
            var v = roiHeight;
            var aa = {};
            var bb = {};
            var cc = {};
            var dd = {};
            var py = 100;
            for (var i = 0; i < drawLines.length; i++) {
                var rho = drawLines[i][0];
                var theta = drawLines[i][1];
                var a = Math.cos(theta);
                var b = Math.sin(theta);
                var x0 = a * rho;
                var y0 = b * rho;
                //switch to canvas coordinate
                var x1 = parseInt(x0 - v * b);
                var y1 = parseInt(y0 + v * a);
                var x2 = parseInt(x0 + v * b);
                var y2 = parseInt(y0 - v * a);
                if (theta * 180 / Math.PI < 90) {
                    if (typeof aa.x == 'undefined') {
                        aa.x = x1; aa.y = y1;
                        bb.x = x2; bb.y = y2;
                    }
                    // left Lane
                    aa.x = x1 < aa.x ? x1 : aa.x;
                    aa.y = y1 > aa.y ? y1 : aa.y;
                    bb.x = x2 > bb.x ? x2 : bb.x;
                    bb.y = y2 < bb.y ? y2 : bb.y;
                    lastLeftLane = rtnDot(
                        { x: -10 * roiWidth, y: py }, { x: 10 * roiWidth, y: py },
                        { x: aa.x, y: aa.y }, { x: bb.x, y: bb.y });
                } else {
                    if (typeof cc.x == 'undefined') {
                        cc.x = x2; cc.y = y2;
                        dd.x = x1; dd.y = y1;
                    }
                    // right Lane
                    cc.x = x2 > cc.x ? x2 : cc.x;
                    cc.y = y2 > cc.y ? y2 : cc.y;
                    dd.x = x1 < dd.x ? x1 : dd.x;
                    dd.y = y1 < dd.y ? y1 : dd.y;
                    lastRightLane = rtnDot(
                        { x: -10 * roiWidth, y: py }, { x: 10 * roiWidth, y: py },
                        { x: cc.x, y: cc.y }, { x: dd.x, y: dd.y });
                }
            }
        }

        function drawCircle(context, centerX, centerY, radius, color) {
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
            context.fillStyle = 'green';
            context.fill();
            context.lineWidth = 5;
            context.strokeStyle = color;
            context.stroke();
        }

        function drawLine(ctx, a, b) {
            ctx.beginPath();
            ctx.fillStyle = 'green';
            ctx.fill();
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#003300';
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
        }
        //http://www.cnblogs.com/i-gps/archive/2012/06/19/2554992.html
        function rtnDot(a, b, c, d) {
            // 三角形abc 面积的2倍  
            var area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
            // 三角形abd 面积的2倍  
            var area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);
            // 面积符号相同则两点在线段同侧,不相交 (对点在线段上的情况,本例当作不相交处理);  
            if (area_abc * area_abd >= 0) {
                return false;
            }
            // 三角形cda 面积的2倍  
            var area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);
            // 三角形cdb 面积的2倍  
            // 注意: 这里有一个小优化.不需要再用公式计算面积,而是通过已知的三个面积加减得出.  
            var area_cdb = area_cda + area_abc - area_abd;
            if (area_cda * area_cdb >= 0) {
                return false;
            }
            //计算交点坐标  
            var t = area_cda / (area_abd - area_abc);
            var dx = t * (b.x - a.x),
                dy = t * (b.y - a.y);
            return { x: a.x + dx, y: a.y + dy };
        }
        //test code , {x:50,y:50} is ok
        //console.log(rtnDot({x:0,y:100},{x:100,y:0},{x:100,y:100},{x:0,y:0}));
    </script>
</body>

</html>